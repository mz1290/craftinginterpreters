package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

// https://github.com/nanmu42/bluelox/blob/3e596a1efff6dee6a5f320f8d20fe00e7db9e1f2/cmd/gen-ast-types/gen-ast-types.go
// https://github.com/n4to4/glox/blob/dd0c6a494d1377b368d8e0c374802233712a72d9/tool/generate.go
// https://github.com/goropikari/golox/blob/main/tools/generate_ast.go

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: ./generateAST <output directory>")
		os.Exit(64)
	}

	// Store output dir from cli
	outputDir := os.Args[1]
	defineAST(outputDir, "Expr", []string{
		"Assign   : Name *token.Token, Value Expr",
		"Binary   : Left Expr, Operator *token.Token, Right Expr",
		"Call     : Callee Expr , Paren *token.Token, Arguments []Expr",
		"Grouping : Expression Expr",
		"Literal  : Value interface{}",
		"Logical  : Left Expr, Operator *token.Token, Right Expr",
		"Unary    : Operator *token.Token, Right Expr",
		"Variable : Name *token.Token",
	})

	defineAST(outputDir, "Stmt", []string{
		"Block      : Statements []Stmt",
		"Expression : Expression Expr",
		"Function   : Name *token.Token, Params []*token.Token, Body []Stmt",
		"If         : Condition Expr, ThenBranch Stmt, ElseBranch Stmt",
		"Print      : Expression Expr",
		"Var        : Name *token.Token, Initializer Expr",
		"While      : Condition Expr, Body Stmt",
	})
}

func defineAST(outputDir, baseName string, types []string) error {
	// Build full output file path
	path := fmt.Sprintf("%s/%s.go", outputDir, strings.ToLower(baseName))
	fmt.Println(path)

	// Create file
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create %s: %s", path, err)
	}
	defer file.Close()

	// Create writer for new file
	writer := bufio.NewWriter(file)

	// Generate AST
	generateAST(writer, baseName, types)

	// Write data
	writer.Flush()

	return nil
}

func generateAST(w io.StringWriter, baseName string, types []string) {
	w.WriteString(`// Code generated by generateAST; DO NOT EDIT.
package ast

import (
	"github.com/mz1290/golox/internal/pkg/token"
)

`)
	// Generate kind interface
	w.WriteString(fmt.Sprintf("type %s interface {\n", baseName))
	w.WriteString(fmt.Sprintf("\t%sAcceptor\n}\n\n", baseName))

	// Generate visitor interface
	defineVisitor(w, baseName, types)
	w.WriteString("\n")

	// Generate accepor interface
	defineAcceptor(w, baseName)
	w.WriteString("\n")

	for _, t := range types {
		defineType(w, t)
		w.WriteString("\n")

		defineAccept(w, baseName, t)
		w.WriteString("\n")
	}
}

func defineType(w io.StringWriter, t string) {
	splits := strings.Split(t, ":")
	typeName := strings.Trim(splits[0], " ")
	allFields := strings.Trim(splits[1], " ")
	fieldNames := strings.Split(allFields, ", ")

	w.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
	for _, field := range fieldNames {
		w.WriteString(fmt.Sprintf("\t%s\n", field))
	}
	w.WriteString("}\n")
}

func defineVisitor(w io.StringWriter, baseName string, types []string) {
	w.WriteString(fmt.Sprintf("type %sVisitor interface {\n", baseName))

	for _, t := range types {
		splits := strings.Split(t, ":")
		typeName := strings.Trim(splits[0], " ")
		w.WriteString(fmt.Sprintf("\tVisit%s%s(%s %s) (interface{}, error)\n",
			typeName, baseName,
			strings.ToLower(baseName), typeName,
		))
	}

	w.WriteString("}\n")
}

func defineAcceptor(w io.StringWriter, baseName string) {
	w.WriteString(fmt.Sprintf("type %sAcceptor interface {\n", baseName))
	w.WriteString(fmt.Sprintf("\tAccept(v %sVisitor) (interface{}, error)\n",
		baseName))
	w.WriteString("}\n")
}

func defineAccept(w io.StringWriter, baseName string, t string) {
	splits := strings.Split(t, ":")
	typeName := strings.Trim(splits[0], " ")

	w.WriteString(fmt.Sprintf("func (x %s) Accept(v %sVisitor) (interface{}, error) {\n", typeName, baseName))
	w.WriteString(fmt.Sprintf("\treturn v.Visit%s%s(x)\n", typeName, baseName))
	w.WriteString("}\n")
}
